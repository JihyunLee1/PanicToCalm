import os
import json
import requests
import pdb
import re
import random
class AI_CLIENT:
    def __init__(self, demo_config, gpt_config, logger, model_name, client_key = None, client_info = None):
        self.language = demo_config["LANGUAGE"]
        self.demo_config = demo_config  
        self.logger = logger
        os.environ["OPENAI_API_KEY"] = gpt_config["api-key"]
        with open(self.demo_config['client_instruction'], 'r') as f:
            self.instruction = ' '.join(f.readlines())
        self.model_name = model_name
        self.client_key = client_key
        self.client_info = client_info
        
        
    def update_client_info(self, client_info):
        self.client_info = client_info
        self.logger.log_only(f"Client info updated: {self.client_info}")
        
    def update_client_info_randomly(self):
        random.seed()
        self.logger.log_and_print("Updating client info randomly")
        with open(self.demo_config['client_info']) as f:
            clients = json.load(f)
        self.client_key = random.choice(list(clients.keys()))
        self.client_info = clients[self.client_key]
        self.logger.log_only(f"Client info updated: {self.client_info}")
        self.logger.log_only(f"Client key updated: {self.client_key}")
        self.logger.log_only("AI client is ready")
        return self.client_key, self.client_info
        
    def history_to_str(self, history):
        history = history.dialogue
        history_list = []
        for part in ['A', 'B', 'C']:
            if part in history:
                history_list += history[part]['dialogue']
        history_str = ""
        cnt =1 
        for idx, item in enumerate(history_list):
            history_str +=  f"Turn {cnt}\n"
            cnt += 1
            if 'system' in item:
                history_str += f"Counselor: {item['system']}\n"
            if 'user' in item:
                history_str += f"Client: {item['user']}\n\n"
        return history_str
    
    
    
    def get_prompt_move(self, history):
        part = history.current_idx[0]
        main_question = {
            'A': "Did the counselor guide you to a physically safer place where stabilization could begin?",
            'B': "Did the counselor help you feel stable enough by breathing or grounding and de-catastrophizing to end the stabilization? Are you okay to end the session now? Are you feel comfortable?",
            'C': "Did the counselor recommend to meet a professional, and is it okay to end the conversation now?",
        }

        prompt = (
            f"{self.instruction}\n\n"
            "== Your Background ==\n"
            f"{self.client_info}\n\n"
            "== Conversation History ==\n"
            f"{self.history_to_str(history)}\n\n"
            f"== Main Question ==\n"
            f"{main_question[part]}\n\n"
            "Please answer with one of the following JSON formats only. Do not include any explanation or additional reasoning:\n"
            'If the answer is yes:\n{"answer": "yes", "reason" : "brief reason"}\n'
            'If the answer is no:\n{"answer": "no", "reason" : "brief reason"}'
        )

        return prompt
    
        
    def get_prompt_eval_utts(self, utt_list, history):
        
        instruction = (
            "You are evaluating multiple counseling responses (utterances) generated by a chatbot counselor.\n"
            "Each response should be evaluated based on the following two criteria:\n\n"
            "1. **Directive**: How clearly does the utterance guide the user toward stabilization or next steps?\
                In the context of panic disorder counseling, this includes giving concrete behavioral instructions, \
                such as guiding the user to a quieter place, explaining breathing techniques, or providing step-by-step grounding methods. \
                The guidance should be clear, actionable, and appropriate for someone in acute distress.(1 = not directive at all, 5 = very directive)\n"
                
            "2. Empathy: How well does the utterance understand and acknowledge the user's feeling?\
                As this is counseling for severe panic disorder, the tone should be calm, validating, and emotionally grounded, \
                    to help the user feel safe, understood, and not alone. Avoid overly excited utterance. \
                    (1 = no empathy, 5 = highly empathetic)\n\n"
                    
                    
            "You must assign both scores from 1 to 5 for each response, and provide a brief reason justifying your evaluation.\n"
            "Return your output as a JSON dictionary in the following format:\n\n"
            '{\n'
            '  "idx0": {"directive": int, "empathy": int, "reason": "brief reason"},\n'
            '  "idx1": {"directive": int, "empathy": int, "reason": "brief reason"},\n'
            '  ...\n'
            '}\n\n'
            "Do not include any explanation or commentary outside the JSON. Just return the JSON object only."
        )

        history_str = self.history_to_str(history)
        utt_str = "\n\n".join([f"idx{i}. {utt}" for i, utt in enumerate(utt_list)])

        prompt = (
            f"{instruction}\n\n"
            f"== Client Info ==\n{self.client_info}\n\n"
            f"== Conversation History ==\n{history_str}\n\n"
            f"== Counselor Responses ==\n{utt_str}"
        )

        return prompt
        
    
    def postprocess(self, response):
        response = response.replace("Counselor:", "")
        response = response.replace("Client:", "")
        response = response.replace("Client :", "")
        response = response.replace("\n", " ")
        pattern = r"Turn\s+\d+"
        response = re.sub(pattern, "", response).strip()
        return response
    
    def openai_predict(payload, key):
        headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {key}"
        }
                
        response = requests.post("https://api.openai.com/v1/chat/completions",headers=headers, json=payload).json()
        try:
            result =  response['choices'][0]['message']['content']
        except:
            print(response)
            exit()
        return result


    def make_line(self, custom_id, prompt, max_tokens = 5012):
        
        text_content = {
            "type": "text",
            "text": prompt
        }
        content = [text_content]

        payload = {
        "model": self.model_name,
        "messages": [
            {
            "role": "user",
            "content": content
            }
        ],
        "max_tokens": max_tokens
        }
        
        overall = {
            'custom_id' : custom_id,
            'method' : 'POST',
            'url' : '/v1/chat/completions',
            'body' : payload,
        }
        return overall
    

    def openai_predict(self, payload, key):
        headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {key}"
        }
        response = requests.post("https://api.openai.com/v1/chat/completions",headers=headers, json=payload['body']).json()
        try:
            result =  response['choices'][0]['message']['content']
        except:
            print(response)
            exit()
        return result
    
    def get_prompt(self, history):
        prompt = (
            f"{self.instruction} \n\n"
            "This is your role information: \n"
            f"{self.client_info} \n\n"
            "This is the current conversation history: \n"
            f"{self.history_to_str(history)} \n"
            "What would you say next? \n"
            "Do not provide explanations or reasoning—respond naturally as if you are the client in distress.\n"
        )
        if self.language == "kr":
            prompt += "프롬프트 작성은 영어로 했지만, 응답은 반드시 한국어로 해 주세요."
        return prompt

    
    def gpt_run(self, prompt):
        payload = self.make_line("1", prompt)
        result = self.openai_predict(payload, os.environ["OPENAI_API_KEY"])
        return result
    
    def chat(self, history, options=None):
        self.client_info.pop("severity", None)
        assert self.client_info is not None, "Client info is not set. Please update it before running."
        
        prompt = self.get_prompt(history)
            
        response = self.gpt_run(prompt)
        response = self.postprocess(response)
        return response
    
    
    
    def ask_move_to_next(self, history):
        prompt = self.get_prompt_move(history)
        response = self.gpt_run(prompt)
        response = self.postprocess(response) 
        response_dict = self.to_json(response)
        reason = response_dict.get('reason', '')
        if response_dict['answer'].lower() == "yes":
            return True, reason
        else:
            return False, reason
        
        
    def ask_eval_utt(self, utts, history):
        prompt = self.get_prompt_eval_utts(utts, history)
        response = self.gpt_run(prompt)
        response = self.postprocess(response) 
        response_dict = self.to_json(response)
        for idx in response_dict:
            response_dict[idx]['score'] = (response_dict[idx]['directive'] + response_dict[idx]['empathy']) / 2
        
        return response_dict

        
        
    def to_json(self, response_text):
        
        response_text = response_text.replace("\n", "").replace("```json", "").replace("```", "")
        response_text = response_text.replace("Result: ", "")
        # Attempt to parse the JSON content
        try:
            response_data = json.loads(response_text)
        except json.JSONDecodeError:
            print(f"Could not parse JSON: {response_text}")
            return {"error" : str(response_text)}
        return response_data


        